using System;
using System.Collections.Generic;
using System.Text;
using System.Collections;
using System.Diagnostics;
using NppPluginNET;

namespace SnippetExecutor
{
    public interface ISnippetCompiler
    {
        IO stdIO
        {
            set;
        }
		
		IO console
		{
			set;
		}

        String[] UnderstoodArguments
        {
            get;
        }

        System.Collections.Hashtable options { get; }

        /// <summary>
        /// Processes snippet text and returns a string which should
        /// be directly compileable, i.e. if written to a file then executing
        /// the compiler on that file should succeed.
        /// </summary>
        /// <param name="snippetText">the snippet to prepare</param>
        /// <returns>valid source code as a string</returns>
        string PrepareSnippet(String snippetText);

        /// <summary>
        /// Compiles valid source code into an executable.  A reference to the executable
        /// should be returned for later handing to execute.
        /// </summary>
        /// <param name="text">Valid source code, generated by ProcessSnippet</param>
        /// <param name="options">compiler command line options</param>
        /// <returns>an object handle referencing the compiled code</returns>
        Object Compile(String text, string options);

        /// <summary>
        /// Executes the executable created by Compile, hooking stdin and stdout to
        /// the IO object injected in the property.
        /// </summary>
        /// <param name="args">command line arguments for the execution</param>
        /// <returns>true if execution finished without error</returns>
        bool execute(Object executable, string args);

        bool cleanup(SnippetInfo info);
    }

    public interface IO : IDisposable
    {
        void write(String s);

        void writeLine();

        void writeLine(String s);

        int read();

        string readLine();
    }
    
    public abstract class AbstractSnippetCompiler : ISnippetCompiler
    {
        public IO stdIO { 
            set;
            protected get;
        }
		
		public IO console{
			set;
			protected get;
		}

        public abstract String[] UnderstoodArguments
        {
            get;
        }

        protected abstract LangType lang
        {
            get;
        }

        public Hashtable options
        {
            get { return _options; }
        }
        private Hashtable _options = new Hashtable();

        public virtual string PrepareSnippet(string snippetText)
        {
            string toCompile = TemplateLoader.getTemplate(this.lang);
            if (toCompile == null)
            {
                console.writeLine("No template for " + System.IO.Path.GetFullPath("plugins/SnippetExecutor/templates/" + this.lang + ".txt"));
                return null;
            }

            toCompile = TemplateLoader.insertSnippet("snippet", snippetText, toCompile);
            toCompile = TemplateLoader.removeOtherSnippets(toCompile);
            return toCompile;
        }

        public abstract object Compile(string text, string options);

        protected abstract string cmdToExecute(object executable, string args);

        protected abstract string getArgs(object executable, string args);

        public virtual bool execute(object executable, string args)
        {
            Process processObj = new Process();

            if (executable == null) throw new Exception("compile first");

            processObj.StartInfo.FileName = cmdToExecute(executable, args);
            processObj.StartInfo.Arguments = getArgs(executable, args);
            processObj.StartInfo.UseShellExecute = false;
            processObj.StartInfo.CreateNoWindow = true;
            processObj.StartInfo.RedirectStandardOutput = true;
            processObj.StartInfo.RedirectStandardError = true;

			console.writeLine("Starting run at " + DateTime.Now.ToString());
            processObj.Start();

            while (!processObj.HasExited)
            {
                System.Threading.Thread.Sleep(50);

                stdIO.write(processObj.StandardError.ReadToEnd());
                stdIO.write(processObj.StandardOutput.ReadToEnd());
            }

            processObj.WaitForExit();
            stdIO.write(processObj.StandardOutput.ReadToEnd());

            console.writeLine("Finished at " + DateTime.Now.ToString());

            return true;
        }

        public virtual bool cleanup(SnippetInfo info)
        {
            System.IO.File.Delete(cmdToExecute(info.compiled, info.runCmdLine));
            return true;
        }
    }

}
